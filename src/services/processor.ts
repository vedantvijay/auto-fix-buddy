
import { githubService } from './github';
import { aiService } from './ai';
import { configService } from './config';
import { GitHubIssue, GitHubPullRequest } from '../types/github';
import { AISolution } from '../types/ai';

export interface ProcessingResult {
  issue: GitHubIssue;
  solution?: AISolution;
  pullRequest?: GitHubPullRequest;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  error?: string;
  date: string;
}

class ProcessorService {
  private results: ProcessingResult[] = [];
  private processing = false;

  constructor() {
    this.loadFromLocalStorage();
  }

  private loadFromLocalStorage() {
    const savedResults = localStorage.getItem('autopr-results');
    
    if (savedResults) {
      try {
        this.results = JSON.parse(savedResults);
      } catch (error) {
        console.error('Error loading results from localStorage:', error);
      }
    }
  }

  private saveToLocalStorage() {
    localStorage.setItem('autopr-results', JSON.stringify(this.results));
  }

  getResults(): ProcessingResult[] {
    return [...this.results];
  }

  clearResults() {
    this.results = [];
    this.saveToLocalStorage();
  }

  async refreshIssues(): Promise<ProcessingResult[]> {
    if (this.processing) {
      throw new Error('Already processing issues');
    }

    if (!configService.isConfigured()) {
      throw new Error('Services not configured');
    }

    this.processing = true;

    try {
      const config = configService.getConfig();
      
      // Configure services
      githubService.configure(
        config.github.token,
        config.github.owner,
        config.github.repository
      );
      
      aiService.configure(config.gemini.apiKey);
      
      // Fetch open issues
      const issues = await githubService.getOpenIssues(
        config.options.labels.length > 0 ? config.options.labels : undefined
      );
      
      // Update results with new issues
      const now = new Date().toISOString();
      
      for (const issue of issues) {
        // Check if issue already exists in results
        const existingIndex = this.results.findIndex(r => r.issue.id === issue.id);
        
        if (existingIndex === -1) {
          // Add new issue
          this.results.push({
            issue,
            status: 'pending',
            date: now
          });
        } else if (this.results[existingIndex].status === 'pending') {
          // Update pending issue
          this.results[existingIndex].issue = issue;
        }
      }
      
      this.saveToLocalStorage();
      return this.getResults();
    } catch (error) {
      console.error('Error refreshing issues:', error);
      throw error;
    } finally {
      this.processing = false;
    }
  }

  async processIssue(issueId: number): Promise<ProcessingResult> {
    if (!configService.isConfigured()) {
      throw new Error('Services not configured');
    }

    // Find the issue in results
    const issueIndex = this.results.findIndex(r => r.issue.id === issueId);
    
    if (issueIndex === -1) {
      throw new Error(`Issue with ID ${issueId} not found`);
    }
    
    // Update status
    this.results[issueIndex].status = 'processing';
    this.saveToLocalStorage();
    
    try {
      const config = configService.getConfig();
      
      // Configure services
      githubService.configure(
        config.github.token,
        config.github.owner,
        config.github.repository
      );
      
      aiService.configure(config.gemini.apiKey);
      
      // Get the issue details
      const issue = this.results[issueIndex].issue;
      
      // Generate AI solution
      const solution = await aiService.generateSolution({
        issue: {
          title: issue.title,
          body: issue.body,
          number: issue.number,
          repository: `${config.github.owner}/${config.github.repository}`
        }
      });
      
      // Create a new branch
      const branchName = `${config.options.branchPrefix}${issue.number}`;
      await githubService.createBranch(branchName);
      
      // Commit changes
      for (const file of solution.filesToModify) {
        await githubService.updateFile(
          file.path,
          file.content,
          branchName,
          `Fix #${issue.number}: Update ${file.path}`
        );
      }
      
      // Create pull request
      const pullRequest = await githubService.createPullRequest(
        `Fix #${issue.number}: ${issue.title}`,
        `This PR addresses issue #${issue.number}\n\n${solution.explanation}\n\nAutomatically generated by AutoPR.`,
        branchName
      );
      
      // Update result
      this.results[issueIndex] = {
        ...this.results[issueIndex],
        solution,
        pullRequest,
        status: 'completed',
        date: new Date().toISOString()
      };
      
      this.saveToLocalStorage();
      return this.results[issueIndex];
    } catch (error) {
      console.error(`Error processing issue ${issueId}:`, error);
      
      // Update result with error
      this.results[issueIndex] = {
        ...this.results[issueIndex],
        status: 'failed',
        error: error instanceof Error ? error.message : String(error),
        date: new Date().toISOString()
      };
      
      this.saveToLocalStorage();
      return this.results[issueIndex];
    }
  }

  isProcessing(): boolean {
    return this.processing;
  }
}

// Export singleton instance
export const processorService = new ProcessorService();
